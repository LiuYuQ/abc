数据库
1、存储过程？优缺点？
存储过程（CREATE PROC procedure_name；EXECUTE Procedure_name；drop procedure procedure_name）是一组为了完成某种特定功能的SQL语句集，经编译后存储在数据库中，用户通过指定存储过程的名字并给定参数（如果该存储过程带有参数）来调用执行它。
一个存储过程是一个可编程的函数，它在数据库中创建并保存。它可以由SQL语句和一些特殊的控制结构组成。当希望在不同的应用程序或平台上执行相同的函数，或者封装特定功能时，存储过程是非常有用的。数据库中的存储过程可以看做是对面向对象方法的模拟，它允许控制数据的访问方式。
优点：
(1)存储过程增强了SQL语言的功能和灵活性：存储过程可以用流控制语句编写，有很强的灵活性，可以完成复杂的判断和较复杂的运算。 
(2)存储过程允许标准组件式编程：存储过程被创建后，可以在程序中被多次调用，而不必重新编写该存储过程的SQL语句。而且可以随时对存储过程进行修改，对应用程序源代码毫无影响。 
(3)存储过程能实现较快的执行速度：存储过程是预编译的代码块。如果某一操作包含大量的Transaction-SQL代码或分别被多次执行，那么存储过程要比批处理的执行速度快很多。在首次运行一个存储过程时，优化器对其进行分析优化，并且给出最终被存储在系统表中的执行计划。而批处理的Transaction-SQL语句在每次运行时都要进行编译和优化，速度相对要慢一些。 
(4)存储过程能减少网络流量：针对同一个数据库对象的操作（如查询、修改），如果这一操作所涉及的Transaction-SQL语句被组织成存储过程，那么当在客户计算机上调用该存储过程时，网络中传送的只是该调用语句，从而大大增加了网络流量并降低了网络负载。 
(5)存储过程可被作为一种安全机制来充分利用：系统管理员通过执行某一存储过程的权限进行限制，能够实现对相应的数据的访问权限的限制，避免了非授权用户对数据的访问，保证了数据的安全。

2、索引？优缺点？类型？实现方式
索引是对数据库表中一个或多个列的值进行排序的结构，是帮助MySQL高效获取数据的数据结构。
优点：
1.大大加快数据的检索速度；  
2.索引降低了插入、删除、修改等维护任务的速度
    3.创建唯一性索引，保证数据库表中每一行数据的唯一性；  
    4.加速表和表之间的连接；
    5.通过使用索引，可以在查询的过程中使用优化隐藏器，提高系统的性能。
缺点：
　　1.索引需要占用数据表以外的物理存储空间；
　　2.创建索引和维护索引要花费一定的时间；
3.当对表进行更新操作时，索引需要被重建，这样降低了数据的维护速度。
索引类型：
1.唯一索引（UNIQUE）：
CREATE UNIQUE INDEX index_name ON table_name (column_list)；表明此索引的每一个索引值只对应唯一的数据记录，对于单列惟一性索引，这保证单列不包含重复的值。对于多列惟一性索引，保证多个值的组合不重复。
2.主键索引：（primary key）
ALTER TABLE table_name ADD PRIMARY KEY (column_list)；数据库表经常有一列或列组合，其值唯一标识表中的每一行。该列称为表的主键。在数据库关系图中为表定义主键将自动创建主键索引，主键索引是唯一索引的特定类型。该索引要求主键中的每个值都唯一。当在查询中使用主键索引时，它还允许对数据的快速访问。 
3.聚集索引（也叫聚簇索引，cluster）  
在聚集索引中，表中行的物理顺序与键值的逻辑（索引）顺序相同。一个表只能包含一个聚集索引。 如果某索引不是聚集索引，则表中行的物理顺序与键值的逻辑顺序不匹配。与非聚集索引相比，聚集索引通常提供更快的数据访问速度。

实现方式：
1.B+树：
BTree索引是最常用的mysql数据库索引算法，因为它不仅可以被用在=,>,>=,<,<=和between这些比较操作符上，而且还可以用于like操作符，只要它的查询条件是一个不以通配符开头的常量；如果一通配符开头，或者没有使用常量，则不会使用索引。
B+树对比B-树有如下好处：
①io次数少：b+树中间节点只存索引，不存在实际的数据，所以可以存储更多的数据。索引树更加的矮胖，io次数更少。
②性能稳定：b+树数据只存在于叶子节点，查询性能稳定
③范围查询简单：b+树不需要中序遍历，遍历链表即可。

2 Hash索引：
   Hash索引是将索引键通过Hash运算之后，将Hash运算结果的Hash值和所对应的行指针信息存放于一个Hash表中，Hash索引只能用于对等比较，例如=,<=>（相当于=）操作符。由于是一次定位数据，不像BTree索引需要从根节点到枝节点，最后才能访问到页节点这样多次IO访问，所以检索效率远高于BTree索引。
缺点：
1. Hash索引仅仅能满足“=”,“IN”,“<=>”查询，不能使用范围查询。 
2. 联合索引中，Hash索引不能利用部分索引键查询。 
对于联合索引中的多个列，Hash是要么全部使用，要么全部不使用，并不支持BTree支持的联合索引的最优前缀，也就是联合索引的前面一个或几个索引键进行查询时，Hash索引无法被利用。 
3. Hash索引无法避免数据的排序操作 
由于Hash索引中存放的是经过Hash计算之后的Hash值，而且Hash值的大小关系并不一定和Hash运算前的键值完全一样，所以数据库无法利用索引的数据来避免任何排序运算。 
4. Hash索引任何时候都不能避免表扫描 
由于不同索引键存在相同Hash值，所以即使满足某个Hash键值的数据的记录条数，也无法从Hash索引中直接完成查询，还是要通过访问表中的实际数据进行比较，并得到相应的结果。 
5. Hash索引遇到大量Hash值相等的情况后性能并不一定会比BTree高 
对于选择性比较低的索引键，如果创建Hash索引，那么将会存在大量记录指针信息存于同一个Hash值相关联。这样要定位某一条记录时就会非常麻烦，会浪费多次表数据访问，而造成整体性能底下。

3. 位图索引：
    位图索引是一种针对多个字段的简单查询设计一种特殊的索引，适用范围比较小，只适用于字段值固定并且值的种类很少的情况，比如性别，只能有男和女，或者级别，状态等等，并且只有在同时对多个这样的字段查询时才能体现出位图的优势。
位图的基本思想就是对每一个条件都用0或者1来表示，如有5条记录，性别分别是男，女，男，男，女，那么如果使用位图索引就会建立两个位图，对应男的10110和对应女的01001,如果同时对多个这种类型的字段进行and或or查询时，可以使用按位与和按位或来直接得到结果了。

B+树最常用，性能也不差，用于范围查询和单值查询都可以。特别是范围查询，非得用B+树这种顺序的才可以了。
HASH的如果只是对单值查询的话速度会比B+树快一点，但是ORACLE好像不支持HASH索引，只支持HASH表空间。
位图的使用情况很局限，只有很少的情况才能用，一定要确定真正适合使用这种索引才用（值的类型很少并且需要复合查询），否则建立一大堆位图就一点意义都没有了。

3、事务？事务的四大特性？
数据库事务：单个逻辑工作单元所执行的一系列数据库操作，是并发控制的基本单位，是数据库运行中的逻辑工作单位。要么都执行，要么都不执行。事务分为：扁平事务；带有保存点的扁平事务；链事务；嵌套事务；分布式事务。
数据库事务的四大特性（ACID)：
(1) 原子性(Atomicity)：
	原子性指的是，事务中包含的程序作为数据库操作要么全部执行，要么完全不执行。
(2)一致性(Consistency) ：
	一致性指的是在一个事务执行之前和执行之后数据库都必须处于一致性状态。这种特性称为事务的一致性。假如数据库的状态满足所有的完整性约束，就说该数据库是一致的。
(3)隔离性(Isolation)：
	隔离性指并发的事务是相互隔离的。即一个事务内部的操作及正在操作的数据必须封锁起来，不被其它企图进行修改的事务看到。
(4)持久性(Durability)：
	持久性意味着当系统或介质发生故障时，确保已提交事务的更新不能丢失。即一旦一个事务提交，DBMS保证它对数据库中数据的改变应该是永久性的，即对已提交事务的更新能恢复。持久性通过数据库备份和恢复来保证。

4、如何理解数据库的范式？
第一范式(1NF)：确保每一列的原子性。如果每一列都是不可再分的最小数据单元，则满			   足第一范式。
第二范式(2NF)：非主属性必须完全依赖主键。如果一个关系满足1NF，并且除了主键以外			   的其它列都依赖于该主键，则满足二范式。（在1NF基础上消除部分函数			   依赖）
第三范式(3NF)：在1NF基础上，除了主键以外的其它列都不传递依赖于主键列，或者说： 任		      何非主属性不依赖于其它非主属性。（在2NF基础上消除传递依赖）

5、B+树、B-树和红黑树
B-树的特性：
1.关键字集合分布在整颗树中；
2.任何一个关键字出现且只出现在一个结点中；
3.搜索有可能在非叶子结点结束；
4.其搜索性能等价于在关键字全集内做一次二分查找；
5.自动层次控制；
由于限制了除根结点以外的非叶子结点，至少含有M/2个儿子，确保了结点的至少利用率，其最底搜索性能为：O(log2n)只与节点数有关，与M无关。
B+的特性：
1.所有关键字都出现在叶子结点的链表中（稠密索引），且链表中的关键字恰好是有序的；
2.不可能在非叶子结点命中；
3.非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层；
4.更适合用于数据库和操作系统的文件系统；
B+树的查找：对B+树可以进行两种查找运算：
1）从最小关键字起顺序查找；
2）从根结点开始，进行随机查找。
B+树是应文件系统所需而出的一种B-树的变型树。一棵m阶的B+树和m阶的B-树的差异在于：
1.有n棵子树的结点中含有n个关键字，每个关键字不保存数据，只用来索引，所有数据都保存在叶子节点。
2.所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。
3.所有的非终端结点可以看成是索引部分，结点中仅含其子树（根结点）中的最大（或最小）关键字。
通常在B+树上有两个头指针，一个指向根结点，一个指向关键字最小的叶子结点。
红黑树：红黑树就是用红链接表示3-结点的2-3树，是一种自平衡二叉查找树，是在计算机科学中用到的一种数据结构，典型的用途是实现关联数组。
红黑树性质：
1）每个结点要么是红的，要么是黑的。
2）根结点是黑的。
3）每个叶结点，即空结点（NIL）是黑的。
4）如果一个结点是红的，那么它的俩个儿子都是黑的。
5）对每个结点，从该结点到其子孙结点的所有路径上包含相同数目的黑结点。
红黑树的本质：
红黑树是对2-3查找树的改进，只是它们对3结点的表示不同，将3-结点表示为由一条左斜的红色链接相连的两个2-结点。若指向它的链接是红色的，那么该节点为红色，红黑树都既是二叉查找树，也是2-3树
小结：
B树：二叉树，每个结点只存储一个关键字，等于则命中，小于走左结点，大于走右结点；
B-树：多路搜索树，每个结点存储M/2到M个关键字，非叶子结点存储指向关键字范围的子结点；所有关键字在整颗树中出现，且只出现一次，非叶子结点可以命中；
	B+树：在B-树基础上，为叶子结点增加链表指针，所有关键字都在叶子结点中出现，非叶子结点作为叶子结点的索引；B+树总是到叶子结点才命中；
	B*树：在B+树基础上，为非叶子结点也增加链表指针，将结点的最低利用率从1/2提高到2/3；

6、乐观锁和悲观锁？
数据库管理系统（DBMS）中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。乐观并发控制(乐观锁)和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。
①悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。流程如下：
在对任意记录进行修改前，先尝试为该记录加上排他锁（exclusive locking）。
如果加锁失败，说明该记录正在被修改，那么当前查询可能要等待或者抛出异常。
如果成功加锁，那么就可以对记录做修改，事务完成后就会解锁了。
期间如果有其他对该记录做修改或加排他锁的操作，都会等待我们解锁或直接抛出异常。
优缺点：
悲观并发控制实际上是“先取锁再访问”的保守策略，为数据处理的安全提供了保证。但是在效率方面，处理加锁的机制会让数据库产生额外的开销，还有增加产生死锁的机会；另外，在只读型事务处理中由于不会产生冲突，也没必要使用锁，这样做只能增加系统负载；还有会降低了并行性，一个事务如果锁定了某行数据，其他事务就必须等待该事务处理完才可以处理那行数
②乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。
一般的实现乐观锁的方式就是记录数据版本。数据版本,为数据增加的一个版本标识。当读取数据时，将版本标识的值一同读出，数据每更新一次，同时对版本标识进行更新。当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的版本标识进行比对，如果数据库表当前版本号与第一次取出来的版本标识值相等，则予以更新，否则认为是过期数据。实现数据版本有两种方式，第一种是使用版本号，第二种是使用时间戳。
优缺点：
乐观并发控制相信事务之间的数据竞争(data race)的概率是比较小的，因此尽可能直接做下去，直到提交的时候才去锁定，所以不会产生任何锁和死锁。但如果直接简单这么做，还是有可能会遇到不可预期的结果，例如两个事务都读取了数据库的某一行，经过修改以后写回数据库，这时就遇到了问题。

7、视图、游标、触发器？
　　视图是一种虚拟的表，通常是有一个表或者多个表的行或列的子集，具有和物理表相同的功能，可以对视图进行增，删，改，查等操作。特别地，对视图的修改不影响基本表。相比多表查询，它使得我们获取数据更容易。
　　游标是对查询出来的结果集作为一个单元来有效的处理。游标可以定在该单元中的特定行，从结果集的当前行检索一行或多行。可以对结果集当前行做修改。一般不使用游标，但是需要逐条处理数据的时候，游标显得十分重要。
　　在操作mysql的时候，我们知道MySQL检索操作返回一组称为结果集的行。这组返回的行都是与 SQL语句相匹配的行（零行或多行）。使用简单的 SELECT语句，例如，没有办法得到第一行、下一行或前 10行，也不存在每次一行地处理所有行的简单方法（相对于成批地处理它们）。有时，需要在检索出来的行中前进或后退一行或多行。这就是使用游标的原因。游标（cursor）是一个存储在MySQL服务器上的数据库查询，它不是一条 SELECT语句，而是被该语句检索出来的结果集。在存储了游标之后，应用程序可以根据需要滚动或浏览其中的数据。游标主要用于交互式应用，其中用户需要滚动屏幕上的数据，并对数据进行浏览或做出更改。
触发器是与表相关的数据库对象，在满足定义条件时触发，并执行触发器中定义的语句集合。触发器的这种特性可以协助应用在数据库端确保数据库的完整性。

8、数据库隔离级别
1. 未提交读（READ UNCOMMITTED）
事务中的修改，即使没有提交，对其它事务也是可见的。这样会提高性能，但是会导致脏读问题。
2. 提交读（READ COMMITTED）
一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。该级别可以解决脏读为问题，但不能避免不可重复读。
3. 可重复读（REPEATABLE READ）
保证在同一个事务中多次读取同样数据的结果是一样的。可以解决不可重复读的问题，但还是不能避免幻读的问题。MySQL默认的隔离级别是可重复读。
4. 可串行化（SERIALIZABLE）
强制事务串行执行。可以解决所有问题。最高级别的隔离。
并发一致性问题：
1.丢失修改：
T1和T2两个事务都对一个数据进行修改，T1先修改，T2随后修改，T2的修改覆盖了T1的修改。
2.脏读数据：
T1修改一个数据，T2随后读取这个数据。如果T1撤销了这次修改，那么T2读取的数据是脏数据。
3.不可重复读：
T2读取一个数据，T1对该数据做了修改。如果T2再次读取这个数据，此时读取的结果和第一次读取的结果不同。
4.幻读：
T1读取某个范围的数据，T2在这个范围内插入新的数据，T1再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。




9、内连接、外连接、交叉连接
概念：根据两个表或多个表的列之间的关系，从这些表中查询数据。分为三种：内连接、外连接、交叉连接。目的是实现多个表查询操作。
①内连接(INNER JOIN)：
仅将两个表中满足连接条件的行组合起来作为结果集。在内连接中，只有在两个表中匹配的行才能在结果集中出现。【等值连接、自然连接、不等连接】  
②外连接(OUTER JOIN)：
  在内连接的基础上，还包含表中所有不符合条件的数据行，并将相对应的表列填写NULL。【左外连接(LEFT OUTER JOIN或LEFT JOIN)、右外连接(RIGHT OUTER JOIN或RIGHT JOIN)、全外连接(FULL OUTER JOIN或FULL JOIN) 】 
③交叉连接(CROSS JOIN)：      
没有WHERE 子句，它返回连接表中所有数据行的笛卡尔积。

10、NOSQL数据库 —— Redis
　　Redis是一款基于内存的且支持持久化、高性能的Key-Value NoSQL 数据库，其支持丰富数据类型(string，list，set，sorted set，hash)，常被用作缓存的解决方案。Redis具有以下显著特点：
①速度快，因为数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)；
②支持丰富数据类型，支持string，list，set，sorted set，hash；
③支持事务，操作都是原子性，所谓的原子性就是对数据的更改要么全部执行，要么全部不执行；
④丰富的特性：可用于缓存消息，按key设置过期时间，过期后将会自动删除。
