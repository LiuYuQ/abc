计算机网络
1、TCP协议、UDP协议
1、TCP是面向连接的;UDP是面向无连接的，即发送数据之前不需要建立连接；
2、TCP传输单位为TCP报文段，UDP传输单位为用户数据报；
2、TCP提供可靠的服务。Tcp通过校验和，重传控制，序号标识，滑动窗口、确认应答实现可靠传输。如丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。所以通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP只是尽最大努力交付，即不保证可靠传输。
3、UDP具有较好的实时性，数据传输比TCP快，适用于对高速传输和实时性有较高的通信或广播通信。
4、每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信
5、TCP对系统资源要求较多，UDP对系统资源要求较少。

2、HTTP协议、HTTPS协议
HTTP协议用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少，是建立在TCP协议之上的一种应用。HTTP连接是一种“短连接”，要保持客户端程序的在线状态，需要不断地向服务器发起连接请求。
HTTP协议的不安全性：HTTP（超级文本传输协议）HTTP协议以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此，HTTP协议不适合传输一些敏感信息。
HTTPS协议的初衷：（安全套接字层超文本传输协议）HTTPS，为了数据传输的安全，HTTPS在HTTP的基础上加入了SSL协议，SSL依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。HTTPS协议的主要作用可以分为两种：一种是建立一个信息安全通道，来保证数据传输的安全；另一种就是确认网站的真实性。
HTTPS和HTTP的区别主要如下：
1）https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。
2）http是超文本传输协议，信息是明文传输，https则传输经ssl加密后的信息。
3）http和https使用完全不同的连接方式，用的端口也不一样，前者是80，后者是443。
4）http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。
5）HTTP使用TCP三次握手建立连接，客户端和服务器需要交换3个包，而HTTPS需要12个包
【请求https连接、返回证书公钥、产生随机密钥、使用公钥对对称密钥加密、发送加密后的对称密钥、进行经过对称密钥加密的密文通信】

3、拥塞控制、流量控制
流量控制是端到端的控制，例如A通过网络给B发数据，A发送的太快导致B没法接收(B缓冲窗口过小或者处理过慢)，这时候的控制就是流量控制，原理是通过滑动窗口的大小改变来实现。 
拥塞控制是A与B之间的网络发生堵塞导致传输过慢或者丢包，来不及传输。防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不至于过载。拥塞控制是一个全局性的过程，涉及到所有的主机、路由器，以及与降低网络性能有关的所有因素。

4、TCP三次握手、四次挥手
TCP报文格式图：
（1）序号：Seq序号，占32位，用来标识从TCP源端向目的端发送的字节流，发起方发送数据时对此进行标记。
（2）确认号：Ack序号，占32位，只有ACK标志位为1时，确认序号字段才有效，Ack=Seq+1。
（3）标志位：共6个，即URG、ACK、PSH、RST、SYN、FIN等，具体含义如下：
  URG：紧急指针（urgent pointer）有效；  ACK：确认序号有效；  PSH：接收方应该尽快将这个报文交给应用层（传送）；  RST：重置连接；  SYN：发起一个新连接；  FIN：释放一个连接。
为什么需要“三次握手”：
为了防止已失效的连接请求报文段突然又传送到了服务端，防止server端一直等待，浪费资源。若建立连接只需两次握手，客户端并没有太大的变化，在获得服务端的应答后进入ESTABLISHED状态，即确认自己的发送和接受信息的功能正常. 但如果服务端在收到连接请求后就进入ESTABLISHED状态,不能保证客户端能收到自己的信息,此时如果网络拥塞，客户端发送的连接请求迟迟到不了服务端，客户端便超时重发请求，如果服务端正确接收并确认应答，双方便开始通信，通信结束后释放连接。此时，如果那个失效的连接请求抵达了服务端，由于只有两次握手，服务端收到请求就会进入ESTABLISHED状态，等待发送数据或主动发送数据。但此时的客户端早已进入CLOSED状态，服务端将会一直等待下去，这样浪费服务端连接资源。

（1）第一次握手：Client将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。
（2）第二次握手：Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack (number )=J+1，随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。
（3）第三次握手：Client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成。
“四次挥手”：

（1）第一次挥手：Client发送一个FIN=1，seq=u，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。
（2）第二次挥手：Server收到FIN后，发送一个ACK=1，seq=v，确认序号ack=u+1给Client，Server进入CLOSE_WAIT状态。
（3）第三次挥手：Server发送一个FIN=1，ACK=1，seq=w,ack=u+1用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。
（4）第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK=1，seq=u+1，ack=w+1，Server进入CLOSED状态，完成四次挥手。

为什么建立连接是三次握手，而关闭连接却是四次挥手：
  因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端FIN报文收到。只有等到Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。

为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？
答：虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可能最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。在Client发送出最后的ACK回复，但该ACK可能丢失。Server如果没有收到ACK，将不断重复发送FIN片段。所以Client不能立即关闭，它必须确认Server接收到了该ACK。Client会在发送出ACK之后进入到TIME_WAIT状态。Client会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么Client会重发ACK并再次等待2MSL。所谓的2MSL是两倍的MSL(Maximum Segment Lifetime)。MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。


TCP的可靠性：通过发送序号（Seq）和确认序号（ACK）来实现的。ack=seq+1。
·数据包校验：
目的是检测数据在传输过程中的任何变化，若校验出包有错，则丢弃报文段并且不给出响应，这时TCP发送数据端超时后会重发数据；
·对失序数据包重排序：
既然TCP报文段作为IP数据报来传输，而IP数据报的到达可能会失序，因此TCP报文段的到达也可能会失序。TCP将对失序数据进行重新排序，然后才交给应用层；
·丢弃重复数据：
对于重复数据，能够丢弃重复数据；
·应答机制：
当TCP收到发自TCP连接另一端的数据，它将发送一个确认。这个确认不是立即发送，通常将推迟几分之一秒；
·超时重发：
当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段；
·流量控制：
TCP连接的每一方都有固定大小的缓冲空间。TCP的接收端只允许另一端发送接收端缓冲区所能接纳的数据，这可以防止较快主机致使较慢主机的缓冲区溢出，这就是流量控制。TCP使用的流量控制协议是可变大小的滑动窗口协议。

5、HTTP响应状态码
1XX－信息类(Information),表示临时响应并需要请求者继续执行操作的状态代码。
2XX－成功类（Successful）,表示用户请求被正确接收，理解和处理例如：200 OK
3XX-重定向类(Redirection),表示请求没有成功，客户必须采取进一步的动作。
4XX-客户端错误(Client Error)，表示客户端提交的请求有错。
5XX-服务器错误(Server Error)，表示服务器不能完成对请求的处理。
100 Continue 继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表		        示确认，之后发送具体参数信息
200 OK 正常返回信息 
201 Created 请求成功并且服务器创建了新的资源
202 Accepted 服务器已接受请求，但尚未处理
301 Moved Permanently 请求的网页已永久移动到新位置。
302 Found 临时性重定向。还是请求原地址，但是会被转移到其他的url处理
303 See Other 临时性重定向，需要发送新的URL。
304 Not Modified 自从上次请求后，请求的网页未修改过。
400 Bad Request 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。
401 Unauthorized 请求未授权。
403 Forbidden 禁止访问。
404 Not Found 找不到如何与 URI 相匹配的资源。
500 Internal Server Error 最常见的服务器端错误。 
503 Service Unavailable 服务器端暂时无法处理请求（可能是过载或维护）。



6、HTTP协议包括哪些请求？
GET：请求读取由URL所标志的信息。
POST：给服务器添加信息（如注释）。
PUT：在给定的URL下存储一个文档。
DELETE：删除给定的URL所标志的资源。
HEAD等等

7、GET、POST的区别？
Get是从服务器上获取数据，Post是向服务器传送数据。
GET参数通过URL传递，POST放在Request body中。
GET在浏览器回退时是无害的，而POST会再次提交请求。
GET产生的URL地址可以被Bookmark，而POST不可以。
GET请求会被浏览器主动cache，而POST不会，除非手动设置。
GET请求只能进行url编码，而POST支持多种编码方式。
GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。
GET请求在URL中传送的参数是有长度限制的，不能大于2KB，而POST一般默认为不受限制。
GET对参数的数据类型只接受ASCII字符，而POST没有限制。
GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。
GET产生一个TCP数据包，POST产生两个TCP数据包。
【对于GET，浏览器把http header和data一并发送出去，服务器响应200（返回数据）；
对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。Firefox只发送一次。两次包的TCP在验证数据包完整性上好】

8、Cookies和Session的主要区别
1）session保存在服务器，客户端不知道其中的信息；cookie保存在客户端，服务器能够知道其中的信息。 
2）session中保存的是对象，cookie中保存的是字符串。 
3）session不能区分路径，同一个用户在访问一个网站期间，所有的session在任何一个地方都可以访问到。而cookie中如果设置了路径参数，那么同一个网站中不同路径下的cookie互相是访问不到的。 
4）session默认需要借助cookie才能正常工作。如果客户端完全禁止cookie，session，这种方法将失效。但可以URL重写。 
5）session在用户会话结束后就会关闭了，但cookie因为保存在客户端，可以长期保存； 
6）cookie是服务端向客户端写入的小的片段信息。cookie信息保存在服务器缓存区，不会在客户端显现。当你第一次登陆一个网站，服务器向你的机器写得片段信息。你可以在Internet选项中找到存放cookie的文件夹。如果不删除，cookie就一直在这个文件夹中。
7）cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗，考虑到安全应当使用session。
8）单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。
9）建议：将登陆信息等重要信息存放为SESSION，其他信息如果需要保留，可以放在COOKIE中



9、分层协议
OSI分层（7层）：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。
TCP/IP分层（4层）：网络接口层、网际层、运输层、应用层。
五层协议（5层）：物理层、数据链路层、网络层、运输层、应用层。

应用层：FTP（文件传送协议）、Telenet（远程登录协议）、DNS（域名解析协议）、SMTP		（邮件传送协议），POP3协议（邮局协议），HTTP协议。
表示层：JPEG、MPEG、ASII
会话层：NFS、SQL、NETBIOS、RPC
传输层：TCP、UDP、SPX
网络层：IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP、（路由器）
数据链路：PPP、FR、HDLC、VLAN、MAC （网桥，交换机）
物理层：RJ45、CLOCK、IEEE802.3 （中继器，集线器）

每一层的作用如下：
应用层：应用层不仅要提供应用进程所需要的信息交换和远地操作，还要作为互相作用的应		用进程的用户代理（应用协议数据单元APDU）（文件传输，电子邮件，文件服务，		虚拟终端）
表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU）（数据格式化，代码转		换，数据加密）
会话层：建立、管理和终止会话（会话协议数据单元SPDU）
传输层：提供端到端的可靠报文传递和错误恢复（段Segment）（提供端对端的接口）
网络层：负责数据包从源到目的的传递和网际互连（包PackeT）（对数据包选择路由）
数据链路层：将比特组装成帧和点到点的传递（帧Frame）（传输帧和错误检测功能）
物理层：通过媒介透明地传输比特流（比特Bit）（以二进制形式在物理媒体上传输数据）
具体协议：
ICMP协议：因特网控制报文协议。它是TCP/IP协议族的一个子协议，用于在IP主机、路由器之间传递控制消息。
DHCP协议： 动态主机配置协议，是一种让系统得以连接到网络上，并获取所需要的配置参		   数手段。
NAT协议：网络地址转换属接入广域网(WAN)技术，是一种将私有（保留）地址转化为合法	     IP地址的转换技术。
RIP协议：底层是贝尔曼福特算法，它选择路由的度量标准（metric)是跳数，最大跳数是		  15跳，如果大于15跳，它就会丢弃数据包。
OSPF协议：底层是迪杰斯特拉算法，是链路状态路由选择协议，它选择路由的度量标准是		  带宽，延迟。
TCP对应的协议： 
（1）FTP ：定义了文件传输协议。下载文件，上传主页等。（21）端口
（2）Telnet ：它是一种用于远程登陆的端口，用户可以以自己的身份远程连接到计算机上，通过这种端口可以提供一种基于DOS模式下的通信服务。（23）端口
（3） SMTP ：简单邮件传送协议，用于发送邮件。（25）端口
（4） POP3 ：它是和SMTP对应，POP3用于接收邮件。（110）端口。
（5） HTTP协议： 是从 Web 服务器传输超文本到本地浏览器的传送协议。

UDP对应的协议： 
（1） DNS ：用于域名解析服务，将域名地址转换为IP地址。（53）端口。
（2） SNMP ：简单网络管理协议，用来管理网络设备的。（161）端口。
（3） TFTP ：简单文件传输协议，用来在客户机与服务器之间进行简单文件传输的协议，提供不复杂、开销不大的文件传输服务。（69）端口。

10、ARP协议的工作原理
完成IP地址到MAC地址的映射。
1、首先，每个主机都会在自己的ARP缓冲区中建立一个ARP列表，以表示IP地址和MAC地址之间的对应关系。
2、当源主机要发送数据时，首先检查ARP列表中是否有对应IP地址的目的主机的MAC地址，如果有，则直接发送数据，如果没有，就向本网段的所有主机广播发送ARP数据包，该数据包包括的内容有：源主机 IP地址，源主机MAC地址，目的主机的IP 地址。
3、当本网络的所有主机收到该ARP数据包时，首先检查数据包中的IP地址是否是自己的IP地址，如果不是，则忽略该数据包，如果是，则首先从数据包中取出源主机的IP和MAC地址写入到ARP列表中，如果已经存在，则覆盖，然后将自己的MAC地址写入ARP响应包中单播发送，告诉源主机自己是它想要找的MAC地址。
4、源主机收到ARP响应包后。将目的主机的IP和MAC地址写入ARP列表，并利用此信息发送数据。如果源主机一直没有收到ARP响应数据包，表示ARP查询失败。
RARP协议：
RARP是逆地址解析协议，作用是完成硬件地址到IP地址的映射，主要用于无盘工作站，因为给无盘工作站配置的IP地址不能保存。工作流程：在网络中配置一台RARP服务器，里面保存着IP地址和MAC地址的映射关系，当无盘工作站启动后，就封装一个RARP数据包，里面有其MAC地址，然后广播到网络上去，当服务器收到请求包后，就查找对应的MAC地址的IP地址装入响应报文中发回给请求者。因为需要广播请求报文，因此RARP只能用于具有广播能力的网络。

11、IP地址的分类
A类地址：以0开头， 第一个字节范围：0~126（1.0.0.0 - 126.255.255.255）；
B类地址：以10开头， 第一个字节范围：128~191（128.0.0.0 - 191.255.255.255）；
C类地址：以110开头， 第一个字节范围：192~223（192.0.0.0 - 223.255.255.255）；
10.0.0.0—10.255.255.255，172.16.0.0—172.31.255.255，192.168.0.0-192.168.255.255。（Internet上保留地址用于内部）
IP地址与子网掩码相与得到网络号

12、在地址栏打入http://www.baidu.com会发生什么？
当输入www.baidu.com时，计算机会请求DNS服务器，进行域名转换，得到服务器IP地址，同时对服务器发出请求，服务器响应请求，客户端浏览器发起一个HTTP会话到IP地址，然后通过tcp进行封装数据包，输入到网络层。





13、HTTP和Socket的区别?
http 为短连接：客户端发送请求都需要服务器端回送响应.请求结束后，主动释放链接，因此为短连接。通常的做法是，不需要任何数据，也要保持每隔一段时间向服务器发送"保持连接"的请求。这样可以保证客户端在服务器端是"上线"状态。
Socket为长连接：通常情况下Socket 连接就是 TCP 连接，因此 Socket 连接一旦建立,通讯双方开始互发数据内容，直到双方断开连接。在实际应用中，由于网络节点过多，在传输过程中，会被节点断开连接，因此要通过轮询高速网络，该节点处于活跃状态。

14、HTTP1.0 HTTP 1.1 HTTP 2.0主要区别
HTTP1.0 HTTP 1.1主要区别：
1、长连接：HTTP 1.0默认使用短链接，需要使用keep-alive参数来告知服务器端要建立		   一个长连接，而HTTP1.1默认支持长连接。
2、节约带宽：HTTP 1.1支持只发送header信息(不带任何body信息)，如果服务器认为客户端有权限请求服务器，则返回100，否则返回401。客户端如果接受到100，才把请求body发送到服务器。当服务器返回401的时候，客户端就不用发送请求body了，节约了带宽。
3、HOST域：web server上的多个虚拟站点可以共享同一个ip和端口。
HTTP1.0是没有host域的，HTTP1.1才支持这个参数。
HTTP1.1 HTTP 2.0主要区别：
1、多路复用：HTTP2.0使用了多路复用的技术，做到同一个连接并发处理多个请求，而且并发请求的数量比HTTP1.1大了好几个数量级。当然HTTP1.1也可以多建立几个TCP连接，来支持处理更多并发的请求，但是创建TCP连接本身也是有开销的。
2、数据压缩：HTTP1.1不支持header数据的压缩，HTTP2.0使用HPACK算法对header的数据进行压缩，这样数据体积小了，在网络上传输就会更快。
3、服务器推送：当我们对支持HTTP2.0的web server请求数据的时候，服务器会顺便把一些客户端需要的资源一起推送到客户端，客户端直接从本地加载这些资源就可以。这种方式非常合适加载静态资源。

15、DDos 攻击
1. DDos 攻击：
·客户端向服务端发送请求链接数据包
·服务端向客户端发送确认数据包
·客户端不向服务端发送确认数据包，服务器一直等待来自客户端的确认
2.DDos 预防 ( 没有彻底根治的办法，除非不使用TCP )
·限制同时打开SYN半链接的数目
·缩短SYN半链接的Time out 时间
·关闭不必要的服务
